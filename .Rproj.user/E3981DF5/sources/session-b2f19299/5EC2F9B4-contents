# Thu Jan 26 19:44:15 2023 ------------------------------
#teste herodotools
# install packages
devtools::install_github("vanderleidebastiani/daee")
devtools::install_github("nmatzke/BioGeoBEARS")
devtools::install_github("GabrielNakamura/Herodotools")

# libraries
library(daee)
library(BioGeoBEARS)
library(Herodotools)
library(tidyverse)

# load data
data("akodon_sites")
data("akodon_newick")

# data processing
site_xy <- akodon_sites %>% 
  dplyr::select(LONG, LAT) 

akodon_pa <- akodon_sites %>% 
  dplyr::select(-LONG, -LAT)

#checking name in matrix and phylogeny
spp_in_tree <- names(akodon_pa) %in% akodon_newick$tip.label
akodon_pa_tree <- akodon_pa[, spp_in_tree]

library(ggplot2)
coastline <- rnaturalearth::ne_coastline(returnclass = "sf")
map_limits <- list(
  x = c(-95, -30),
  y = c(-55, 12)
)

ncol(akodon_pa_tree) # 10 colunas 
nrow(akodon_pa_tree) # 732 linhas

richness <- rowSums(akodon_pa_tree)
head(richness)
View(richness)

# plot richnes map
coastline <- rnaturalearth::ne_coastline(returnclass = "sf")
map_limits <- list(
  x = c(-95, -30),
  y = c(-55, 12)
)

map_richness <- 
  dplyr::bind_cols(site_xy, richness = richness) %>% 
  ggplot2::ggplot() + 
  ggplot2::geom_raster(ggplot2::aes(x = LONG, y = LAT, fill = richness)) + 
  rcartocolor::scale_fill_carto_c(name = "Richness", type = "quantitative", palette = "SunsetDark") +
  ggplot2::geom_sf(data = coastline) +
  ggplot2::coord_sf(xlim = map_limits$x, ylim = map_limits$y) +
  ggplot2::ggtitle("") +
  ggplot2::xlab("Longitude") +
  ggplot2::ylab("Latitude") +
  ggplot2::labs(fill = "Richness") +
  ggplot2::theme_bw() +
  ggplot2::theme(
    plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "mm"),
    legend.text = element_text(size = 6), 
    axis.text = element_text(size = 5),
    axis.title.x = element_text(size = 9),
    axis.title.y = element_text(size = 9)
  )
map_richness

# construindo evoregions
regions <- 
  Herodotools::calc_evoregions(
    comm = akodon_pa_tree,
    phy = akodon_newick
  )
regions$cluster_evoregions
site_region <- regions$cluster_evoregions

# visualize evoregions
evoregion_df <- data.frame(
  site_xy, 
  site_region
)

r_evoregion <- terra::rast(evoregion_df)
r_evoregion

# Converting evoregion to a spatial polygon data frame, so it can be plotted
sf_evoregion <- terra::as.polygons(r_evoregion) %>% 
  sf::st_as_sf()


# Downloading coastline continents and croping to keep only South America
coastline <- rnaturalearth::ne_coastline(returnclass = "sf")
map_limits <- list(
  x = c(-95, -30),
  y = c(-55, 12)
)

# Assigning the same projection to both spatial objects
sf::st_crs(sf_evoregion) <- sf::st_crs(coastline)


# Colours to plot evoregions
col_five_hues <- c(
  "#3d291a",
           "#a9344f",
           "#578a5b",
           "#83a6c4",
           "#fcc573"
)


map_evoregion <- 
  evoregion_df %>% 
  ggplot2::ggplot() + 
  ggplot2::geom_raster(ggplot2::aes(x = LONG, y = LAT, fill = site_region)) + 
  ggplot2::scale_fill_manual(
    name = "", 
    labels = LETTERS[1:5],
    values = rev(col_five_hues)
  ) +
  ggplot2::geom_sf(data = coastline) +
  ggplot2::geom_sf(
    data = sf_evoregion, 
    color = "#040400",
    fill = NA, 
    size = 0.2) +
  ggplot2::coord_sf(xlim = map_limits$x, ylim = map_limits$y) +
  ggplot2::ggtitle("") + 
  ggplot2::theme_bw() +
  ggplot2::xlab("Longitude") +
  ggplot2::ylab("Latitude") +
  ggplot2::theme(
    legend.position = "bottom",
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.text = element_text(color = "black", size = 8)
  )
map_evoregion

# pertencimento a cada evoregion

# Selecting only axis with more than 5% of explained variance from evoregion output
axis_sel <- which(regions$PCPS$prop_explainded >= regions$PCPS$tresh_dist)
PCPS_thresh <- regions$PCPS$vectors[, axis_sel] 

# distance matrix using 4 significant PCPS axis accordingly to the 5% threshold 
dist_phylo_PCPS <- vegan::vegdist(PCPS_thresh, method = "euclidean")

# calculating affiliation values for each assemblage 
afi <- calc_affiliation_evoreg(phylo.comp.dist = dist_phylo_PCPS,
                               groups = site_region) 

# binding the information in a data frame
sites <- dplyr::bind_cols(site_xy, site_region =  site_region, afi)

map_joint_evoregion_afilliation <- 
  evoregion_df %>% 
  ggplot() + 
  ggplot2::geom_raster(ggplot2::aes(x = LONG, y = LAT, fill = site_region), 
                       alpha = sites[, "afilliation"]) + 
  ggplot2::scale_fill_manual(
    name = "", 
    labels = LETTERS[1:5],
    values = rev(col_five_hues)
  ) +
  ggplot2::geom_sf(data = coastline, size = 0.4) +
  ggplot2::geom_sf(
    data = sf_evoregion, 
    color = rev(col_five_hues),
    fill = NA, 
    size = 0.7) +
  ggplot2::coord_sf(xlim = map_limits$x, ylim = map_limits$y) +
  ggplot2::ggtitle("") + 
  guides(guide_legend(direction = "vertical")) +
  ggplot2::theme_bw() +
  ggplot2::xlab("Longitude") +
  ggplot2::ylab("Latitude") +
  ggplot2::theme(
    legend.position = "bottom",
    axis.title = element_text(size = 10)
  )

map_joint_evoregion_afilliation

# temos que definir a ocorrência de cada espécie nas evoregiões. Para fazer isso, podemos usar a função get_region_occe obter um quadro de dados de espécies nas linhas e evoregiões nas colunas.
a_region <- Herodotools::get_region_occ(comm = akodon_pa_tree, site.region = site_region)


# O objeto criado na última etapa pode ser usado em uma função auxiliar no Herodotools para produzir facilmente o arquivo Phyllip necessário para executar a análise da reconstrução da área ancestral usando o BioGeoBEARS.
# save phyllip file
Herodotools::get_tipranges_to_BioGeoBEARS(a_region,filename = "geo_area_akodon.data",areanames = NULL)

here::here("inst", "extdata", "geo_area_akodon.data")
