)
# remove species in list of species
ncol(mammals_list_phy) #695 spp
mammals_list_biogeo <- mammals_list_phy[,!(names(mammals_list_phy)%in% remove)]
ncol(mammals_list_biogeo) #692 spp
remove <- c("Akodon_montensis", "Bibimys_labiosus", "Callithrix_penicillata", "Cavia_aperea", "Cerdocyon_thous", "Chrysocyon_brachyurus", "Coendou_prehensilis", "Coendou_spinosus", "Cuniculus_paca", "Dasypus_novemcinctus", "Didelphis_albiventris", "Euphractus_sexcinctus", "Euryzygomatomys_spinosus", "Galictis_cuja", "Herpailurus_yagouaroundi", "Hydrochoerus_hydrochaeris", "Kannabateomys_amblyonyx", "Lontra_longicaudis", "Mazama_gouazoubira", "Monodelphis_dimidiata", "Monodelphis_domestica", "Myrmecophaga_tridactyla", "Nasua_nasua", "Necromys_lasiurus", "Nectomys_squamipes","Oligoryzomys_eliurus", "Oligoryzomys_nigripes", "Pecari_tajacu", "Procyon_cancrivorus", "Puma_concolor", "Sapajus_nigritus", "Sciurus_aestuans", "Speothos_venaticus", "Tamandua_tetradactyla", "Tapirus_terrestris", "Tayassu_pecari")
# remove species in list of species
ncol(mammals_list_phy) #196 spp
mammals_list_biogeo <- mammals_list_phy[,!(names(mammals_list_phy)%in% remove)]
ncol(mammals_list_biogeo) #692 spp
# calculating age arrival
age_comm <- Herodotools::calc_age_arrival(W = mammals_list_biogeo,
tree = mammals_phy_bio,
ancestral.area = node_area,
biogeo = biogeo_area)
log10(age_comm$mean_age_per_assemblage)
sites <- dplyr::bind_cols(coords, site_region =  evoregion_mammals$site_region_mammals, age = age_comm$mean_age_per_assemblage)
map_age <-
sites %>%
ggplot() +
ggplot2::geom_raster(ggplot2::aes(x = V1, y = V2, fill = log10(mean_age_arrival))) +
rcartocolor::scale_fill_carto_c(type = "quantitative",
palette = "SunsetDark",
direction = 1,
limits = c(0, 3.5),  ## max percent overall
breaks = seq(0, 3.5, by = .5),
labels = glue::glue("{seq(0, 3.5, by = 0.5)}")) +
ggplot2::geom_sf(data = coastline, size = 0.4) +
ggplot2::coord_sf(xlim = map_limits$x, ylim = map_limits$y) +
ggplot2::ggtitle("") +
ggplot2::theme_bw() +
ggplot2::labs(fill = "Mean age (Myr)") +
ggplot2::guides(fill = guide_colorbar(barheight = unit(2.3, units = "mm"),
direction = "horizontal",
ticks.colour = "grey20",
title.position = "top",
label.position = "bottom",
title.hjust = 0.5)) +
ggplot2::theme(
legend.position = "bottom",
axis.title = element_blank(),
legend.text = element_text(size = 10),
axis.text = element_text(size = 5),
plot.subtitle = element_text(hjust = 0.5)
)
map_age
map_age <-
sites %>%
ggplot() +
ggplot2::geom_raster(ggplot2::aes(x = V1, y = V2, fill = mean_age_arrival)) +
rcartocolor::scale_fill_carto_c(type = "quantitative",
palette = "SunsetDark",
direction = 1,
limits = c(0, 3.5),  ## max percent overall
breaks = seq(0, 3.5, by = .5),
labels = glue::glue("{seq(0, 3.5, by = 0.5)}")) +
ggplot2::geom_sf(data = coastline, size = 0.4) +
ggplot2::coord_sf(xlim = map_limits$x, ylim = map_limits$y) +
ggplot2::ggtitle("") +
ggplot2::theme_bw() +
ggplot2::labs(fill = "Mean age (Myr)") +
ggplot2::guides(fill = guide_colorbar(barheight = unit(2.3, units = "mm"),
direction = "horizontal",
ticks.colour = "grey20",
title.position = "top",
label.position = "bottom",
title.hjust = 0.5)) +
ggplot2::theme(
legend.position = "bottom",
axis.title = element_blank(),
legend.text = element_text(size = 10),
axis.text = element_text(size = 5),
plot.subtitle = element_text(hjust = 0.5)
)
map_age
# Save dataset
age_mammals <- cbind(coords_id,sites[,3:4])
write.table(age_mammals,"assemblage_age/age_mammals.txt")
read.table('assemblage_age/age_mammals.txt')
#
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages,
#    i.e. genetically isolated populations.  These may or may not be identical
#    with species.  You would NOT want to just use specimens, as each specimen
#    automatically can only live in 1 area, which will typically favor DEC+J
#    models.  This is fine if the species/lineages really do live in single areas,
#    but you wouldn't want to assume this without thinking about it at least.
#    In summary, you should collapse multiple specimens into species/lineages if
#    data indicates they are the same genetic population.
######################################################
geog.path <- here("assemblage_age/geo_area_birds.data")
# This is the example geography file for Hawaiian Psychotria
# (from Ree & Smith 2008)
geogfn = np(geog.path)
# Look at your geographic range data:
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)
tipranges
# Look at your geographic range data:
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)
tipranges
# Maximum range size observed:
max(rowSums(dfnums_to_numeric(tipranges@df)))
# Set the maximum number of areas any species may occupy; this cannot be larger
# than the number of areas you set up, but it can be smaller.
max_range_size = 3
numstates_from_numareas(numareas=5,
maxareas=3,
include_null_range=FALSE)
trfn = np(phy.path)
geogfn = np(geog.path)
# Intitialize a default model (DEC model)
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
# Give BioGeoBEARS the location of the phylogeny Newick file
BioGeoBEARS_run_object$trfn = trfn
# Give BioGeoBEARS the location of the geography text file
BioGeoBEARS_run_object$geogfn = geogfn
# Input the maximum range size
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.
# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 12
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,
# but the results are imprecise and so I haven't explored it further.
# In a Bayesian analysis, it might work OK, but the ML point estimates are
# not identical.
# Also, I have not implemented all functions to work with force_sparse=TRUE.
# Volunteers are welcome to work on it!!
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)
# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.
BioGeoBEARS_run_object
# This contains the model object
BioGeoBEARS_run_object$BioGeoBEARS_model_object
# This table contains the parameters of the model
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table
# Run this to check inputs. Read the error messages if you get them!
check_BioGeoBEARS_run(BioGeoBEARS_run_object)
# Set your tree file and geography file names
#trfn = "tree5.newick"
trfn = "assemblage_age/birds_biogeo.new"
geogfn = "assemblage_age/geo_area_birds.data"
#######################################################
# Load the tree
#
# Your tree file should be Newick format. If, for
# some reason, you've got a NEXUS file, this will attempt to
# convert to Newick.
#######################################################
# Tree file
try_result = try(read.tree(trfn))
nexTF = grepl(pattern="missing value where TRUE/FALSE needed", x=try_result)
if ( (length(nexTF) == 1) && (nexTF == TRUE) )
{
cat("\n\nERROR: Reading the tree file as NEXUS resulted in this error:\n\n")
print(try_result)
cat("\n...probably this means it is NEXUS rather than Newick. We will attempt to\nread it as NEXUS next, and save to Newick.")
try_result = try(read.nexus(trfn))
if (class(try_result) == "phylo")
{
cat("\n\nFile was NEXUS. Converting to Newick.\n\n")
new_trfn = paste0(trfn, ".newick")
cat(trfn, " --> ", new_trfn)
write.tree(tr, file=new_trfn)
trfn = new_trfn
tr = try_result
} # END if (class(try_result) == "phylo")
if (class(try_result) == "try-error")
{
stoptxt = "ERROR: Reading the tree failed for both read.tree() and read.nexus. Look at your file and verify the format!"
cat("\n\n")
cat(stoptxt)
cat("\n\n")
stop()
} else {
tr = try_result
}# END if (class(try_result) = "try-error")
} else {
# Presumably it's Newick
tr = try_result
} # END if (nexTF == TRUE)
plot(tr)
title("Newick tree")
axisPhylo()
# Is the tree dichotomous?  And rooted?
if (is.binary.tree(tr) == FALSE)
{
stop("Stopping, because tree is not binary. (In other words, you have polytomies. BioGeoBEARS cannot handle polytomies.)")
}
if (is.rooted(tr) == FALSE)
{
stop("Stopping, because tree is not rooted. (BioGeoBEARS requires rooted trees.)")
}
#######################################################
# Check for negative and 0-length branches
# Note: in BioGeoBEARS, tips with branches very close to length 0 (but not exactly 0)
#       are treated as direct ancestors.  But, negative branchlengths, and internal
#       branchlengths=0, all have to be fixed.
#######################################################
# Minimum branchlength for any new internal branches
min_brlen = 0.01
# Are there 0-length branches?
min(tr$edge.length)
# Remove branchlengths less than 0
if (min(tr$edge.length) < 0)
{
cat("\n\n")
cat("Negative branchlengths detected at these nodes:\n\n")
trtable = prt(tr, printflag=FALSE)
negative_brlens_TF = trtable$edge.length < 0
negative_brlens_TF[is.na(negative_brlens_TF)] = FALSE
negative_BL_rows = trtable[negative_brlens_TF, ]
print(negative_BL_rows)
cat("\n")
cat("Correcting, using impose_min_brlen()")
tr = impose_min_brlen(phy=tr, min_brlen=min_brlen, leave_BL0_terminals=TRUE)
if (grepl(pattern="\\.newick", x=trfn) == TRUE)
{
new_trfn = gsub(pattern="\\.newick", replacement="_noNeg.newick", x=trfn)
} else {
new_trfn = paste0(trfn, "_noNeg.newick")
}
trfn = new_trfn
write.tree(tr, file=new_trfn)
cat("\n\nFixed negative branchlengths, and saved to ", new_trfn, "\n", sep="")
} # END if (min(tr$edge.length) < 0)
min(tr$edge.length)
sum(tr$edge.length == min(tr$edge.length))
#######################################################
# *Internal* branches of 0 length?
#######################################################
trtable = prt(tr, printflag=FALSE)
internal_TF = trtable$node.type == "internal"
edges_BL0_TF = trtable$edge.length == 0
sum_TFs = (internal_TF + edges_BL0_TF)
sum_TFs[is.na(sum_TFs)] = 0
internal_BL0_TF = (sum_TFs == 2)
sum(internal_BL0_TF)
# Edit the branchlengths, if needed
if (sum(internal_BL0_TF) > 0)
{
internal_BL0_rows = trtable[internal_BL0_TF, ]
internal_BL0_rows
nodes_to_change = internal_BL0_rows$node
edges_to_change = internal_BL0_rows$parent_br
edges_to_change
cat("\n\n")
cat("Internal branches of length 0 detected at these nodes:\n\n")
print(internal_BL0_rows)
cat("\n")
cat("Changing to length min_brlen=", min_brlen, "...")
tr$edge.length[edges_to_change] = min_brlen
# New filename
if (grepl(pattern="\\.newick", x=trfn) == TRUE)
{
new_trfn = gsub(pattern="\\.newick", replacement="_minBL.newick", x=trfn)
} else {
new_trfn = paste0(trfn, "_minBL.newick")
}
trfn = new_trfn
write.tree(tr, file=new_trfn)
cat("...saved to ", new_trfn, "\n", sep="")
} # END if (sum(internal_BL0_TF) > 0)
##################################################
# *External* branches of 0 length?
##################################################
external_TF = trtable$node.type == "tip"
edges_BL0_TF = trtable$edge.length == 0
sum_TFs = (external_TF + edges_BL0_TF)
sum_TFs[is.na(sum_TFs)] = 0
external_BL0_TF = (sum_TFs == 2)
sum(external_BL0_TF)
tip_brlen = 0.0000001
if (sum(external_BL0_TF) > 0)
{
cat("\n\n")
cat("Tip branches of length zero detected. Changing to length ", tip_brlen, sep="")
cat("\n\n")
edgenums_to_change = trtable$parent_br[external_BL0_TF]
edgenums_to_change
# Change them
tr$edge.length[edgenums_to_change] = tip_brlen
# New filename
if (grepl(pattern="\\.newick", x=trfn) == TRUE)
{
new_trfn = gsub(pattern="\\.newick", replacement="_tipsNo0.newick", x=trfn)
} else {
new_trfn = paste0(trfn, "_tipsNo0.newick")
}
trfn = new_trfn
write.tree(tr, file=new_trfn)
cat("...saved to ", new_trfn, "\n", sep="")
} # END if (sum(external_BL0_TF) > 0)
#######################################################
# Try loading the geography file
#######################################################
# Look at your geographic range data:
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)
tipranges
#######################################################
# Final check
#######################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
# Specify tree file and geography file
BioGeoBEARS_run_object$trfn = trfn
BioGeoBEARS_run_object$geogfn = geogfn
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)
check_BioGeoBEARS_run(BioGeoBEARS_run_object)
# Intitialize a default model (DEC model)
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
# Give BioGeoBEARS the location of the phylogeny Newick file
BioGeoBEARS_run_object$trfn = trfn
# Give BioGeoBEARS the location of the geography text file
BioGeoBEARS_run_object$geogfn = geogfn
# Input the maximum range size
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.
# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 12
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,
# but the results are imprecise and so I haven't explored it further.
# In a Bayesian analysis, it might work OK, but the ML point estimates are
# not identical.
# Also, I have not implemented all functions to work with force_sparse=TRUE.
# Volunteers are welcome to work on it!!
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)
# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.
BioGeoBEARS_run_object
# This contains the model object
BioGeoBEARS_run_object$BioGeoBEARS_model_object
# This table contains the parameters of the model
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table
# Run this to check inputs. Read the error messages if you get them!
check_BioGeoBEARS_run(BioGeoBEARS_run_object)
# Run DEC model and save results
res = bears_optim_run(BioGeoBEARS_run_object)
resDEC = res
#######################################################
# Run DEC+J
#######################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
BioGeoBEARS_run_object$trfn = trfn
BioGeoBEARS_run_object$geogfn = geogfn
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.
# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 12
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)
# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run
# Set up DEC+J model
# Get the ML parameter values from the 2-parameter nested model
# (this will ensure that the 3-parameter model always does at least as good)
dstart = resDEC$outputs@params_table["d","est"]
estart = resDEC$outputs@params_table["e","est"]
jstart = 0.0001
# Input starting values for d, e
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart
# Add j as a free parameter
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart
check_BioGeoBEARS_run(BioGeoBEARS_run_object)
# Run DECj model and save results
resJ = bears_optim_run(BioGeoBEARS_run_object)
resDECj = resJ
# Set up empty tables to hold the statistical results
restable = NULL
teststable = NULL
#######################################################
# Statistics -- DEC vs. DEC+J
#######################################################
# We have to extract the log-likelihood differently, depending on the
# version of optim/optimx
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)
numparams1 = 3
numparams2 = 2
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)
stats
# DEC, null model for Likelihood Ratio Test (LRT)
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)
# DEC+J, alternative model for Likelihood Ratio Test (LRT)
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)
rbind(res2, res1)
tmp_tests = conditional_format_table(stats)
restable = rbind(restable, res2, res1)
teststable = rbind(teststable, tmp_tests)
#########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J
#########################################################################
teststable$alt = c("DEC+J")
teststable$null = c("DEC")
row.names(restable) = c("DEC", "DEC+J")
restable = put_jcol_after_ecol(restable)
#######################################################
# Model weights of all six models
#######################################################
restable2 = restable
# With AICs:
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)
restable = cbind(restable, AICtable)
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)
restable_AIC_rellike
# With AICcs -- factors in sample size
tr <- read.tree(trfn)
samplesize = length(tr$tip.label)
AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)
restable2 = cbind(restable2, AICtable)
restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")
restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)
restable_AICc_rellike
list.results.BioGeoBears <- list(resDEC = resDEC,
resDECj = resDECj,
table_AIC = restable_AIC_rellike ,
table_AICc = restable_AICc_rellike)
result_birds <-  list.results.BioGeoBears$table_AICc %>%
dplyr::arrange(AICc) %>%
mutate(delta_AICc =  AICc - min(AICc))
save(resDECj, file =  "assemblage_age/resDECj_birds.RData")
cat("The best models are 'resDECj'")
write.csv2(result_birds,"result_biogeobears.csv")
# idade da comunidade
# converting numbers to character
biogeo_area <- data.frame(biogeo = chartr("12345", "ABCDE", evoregion_birds$site_region_birds))
# getting the ancestral range area for each node
node_area <-
Herodotools::get_node_range_BioGeoBEARS(
resDECj,
phyllip.file = "assemblage_age/geo_area_birds.data",
birds_phy_bio,
max.range.size = 3
)
# remove species in list of species
ncol(birds_list_phy) #695 spp
remove <- c("Crotophaga_major", "Crypturellus_parvirostris", "Turdus_leucomelas")
birds_list_biogeo <- birds_list_phy[,!(names(birds_list_phy)%in% remove)]
ncol(birds_list_biogeo) #692 spp
# calculating age arrival
age_comm <- Herodotools::calc_age_arrival(W = birds_list_biogeo,
tree = birds_phy_bio,
ancestral.area = node_area,
biogeo = biogeo_area)
log10(age_comm$mean_age_per_assemblage)
sites <- dplyr::bind_cols(coords, site_region =  evoregion_birds$site_region_birds, age = age_comm$mean_age_per_assemblage)
map_age <-
sites %>%
ggplot() +
ggplot2::geom_raster(ggplot2::aes(x = V1, y = V2, fill = log10(mean_age_arrival))) +
rcartocolor::scale_fill_carto_c(type = "quantitative",
palette = "SunsetDark",
direction = 1,
limits = c(0, 3.5),  ## max percent overall
breaks = seq(0, 3.5, by = .5),
labels = glue::glue("{seq(0, 3.5, by = 0.5)}")) +
ggplot2::geom_sf(data = coastline, size = 0.4) +
ggplot2::coord_sf(xlim = map_limits$x, ylim = map_limits$y) +
ggplot2::ggtitle("") +
ggplot2::theme_bw() +
ggplot2::labs(fill = "Mean age (Myr)") +
ggplot2::guides(fill = guide_colorbar(barheight = unit(2.3, units = "mm"),
direction = "horizontal",
ticks.colour = "grey20",
title.position = "top",
label.position = "bottom",
title.hjust = 0.5)) +
ggplot2::theme(
legend.position = "bottom",
axis.title = element_blank(),
legend.text = element_text(size = 10),
axis.text = element_text(size = 5),
plot.subtitle = element_text(hjust = 0.5)
)
map_age
# Save dataset
age_birds <- cbind(coords_id,sites[,3:4])
write.table(age_birds,"assemblage_age/age_birds.txt")
read.table('assemblage_age/age_birds.txt')
